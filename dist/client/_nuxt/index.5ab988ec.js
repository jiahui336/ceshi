import{a as m,o as P,b as w,e as _,f as y,r as B,h as $,i as p,j as x,k as O,l as g,w as b,u as A,m as M,p as z}from"./entry.f2096148.js";const E={};function H(a,u){return"顶部"}const j=m(E,[["render",H]]),N={};function F(a,u){return"底部"}const K=m(N,[["render",F]]),R={};function S(a,u){const e=j,o=K;return P(),w("div",null,[_("div",null,[y(e)]),_("div",null,[B(a.$slots,"default")]),_("div",null,[y(o)])])}const T=m(R,[["render",S]]),V=()=>null;function I(...a){var D;const u=typeof a[a.length-1]=="string"?a.pop():void 0;typeof a[0]!="string"&&a.unshift(u);let[e,o,n={}]=a;if(typeof e!="string")throw new TypeError("[nuxt] [asyncData] key must be a string.");if(typeof o!="function")throw new TypeError("[nuxt] [asyncData] handler must be a function.");n.server=n.server??!0,n.default=n.default??V,n.lazy=n.lazy??!1,n.immediate=n.immediate??!0;const t=$(),f=()=>t.isHydrating?t.payload.data[e]:t.static.data[e],d=()=>f()!==void 0;t._asyncData[e]||(t._asyncData[e]={data:p(f()??((D=n.default)==null?void 0:D.call(n))??null),pending:p(!d()),error:p(t.payload._errors[e]?x(t.payload._errors[e]):null)});const r={...t._asyncData[e]};r.refresh=r.execute=(c={})=>{if(t._asyncDataPromises[e]){if(c.dedupe===!1)return t._asyncDataPromises[e];t._asyncDataPromises[e].cancelled=!0}if(c._initial&&d())return f();r.pending.value=!0;const l=new Promise((s,i)=>{try{s(o(t))}catch(C){i(C)}}).then(s=>{if(l.cancelled)return t._asyncDataPromises[e];let i=s;n.transform&&(i=n.transform(s)),n.pick&&(i=U(i,n.pick)),r.data.value=i,r.error.value=null}).catch(s=>{var i;if(l.cancelled)return t._asyncDataPromises[e];r.error.value=s,r.data.value=A(((i=n.default)==null?void 0:i.call(n))??null)}).finally(()=>{l.cancelled||(r.pending.value=!1,t.payload.data[e]=r.data.value,r.error.value&&(t.payload._errors[e]=x(r.error.value)),delete t._asyncDataPromises[e])});return t._asyncDataPromises[e]=l,t._asyncDataPromises[e]};const h=()=>r.refresh({_initial:!0}),k=n.server!==!1&&t.payload.serverRendered;{const c=M();if(c&&!c._nuxtOnBeforeMountCbs){c._nuxtOnBeforeMountCbs=[];const s=c._nuxtOnBeforeMountCbs;c&&(O(()=>{s.forEach(i=>{i()}),s.splice(0,s.length)}),g(()=>s.splice(0,s.length)))}k&&t.isHydrating&&d()?r.pending.value=!1:c&&(t.payload.serverRendered&&t.isHydrating||n.lazy)&&n.immediate?c._nuxtOnBeforeMountCbs.push(h):n.immediate&&h(),n.watch&&b(n.watch,()=>r.refresh());const l=t.hook("app:data:refresh",s=>{if(!s||s.includes(e))return r.refresh()});c&&g(l)}const v=Promise.resolve(t._asyncDataPromises[e]).then(()=>r);return Object.assign(v,r),v}function L(...a){const u=typeof a[a.length-1]=="string"?a.pop():void 0;typeof a[0]!="string"&&a.unshift(u);const[e,o,n]=a;return I(e,o,{...n,lazy:!0},null)}function U(a,u){const e={};for(const o of u)e[o]=a[o];return e}const G=z({__name:"index",setup(a){const{pending:u,data:e}=L("count",()=>$fetch("/api/count"));return b(e,o=>{console.log("触发了")}),(o,n)=>{const t=T;return P(),w("div",null,[y(t)])}}});export{G as default};
